package org.leetvision.parser.meta.mapper;

import java.util.HashMap;
import java.util.Map;

import static org.leetvision.parser.meta.MetaLanguage.MetaNode;

public final class GoLanguageMapper extends LanguageMapper {
    public static final GoLanguageMapper INSTANCE = new GoLanguageMapper(new HashMap<>() {{
        put("sourceFile", MetaNode.PROGRAM);
        put("packageClause", VOID_MAPPING);
        put("importDecl", VOID_MAPPING);
        put("importSpec", VOID_MAPPING);
        put("importPath", VOID_MAPPING);
        put("declaration", MetaNode.MEMBER_DECLARATION);
        put("constDecl", MetaNode.CONST_DECLARATION);
        put("constSpec", MetaNode.CONSTANT_DECLARATOR);
        put("identifierList", MetaNode.EXPRESSION_LIST);
        put("expressionList", MetaNode.EXPRESSION_LIST);
        put("typeDecl", MetaNode.TYPE_DECLARATION);
        put("typeSpec", MetaNode.TYPE);
        put("aliasDecl", MetaNode.TYPE);
        put("typeDef", MetaNode.TYPEDEF);
        put("typeParameters", MetaNode.TYPE_PARAMETERS);
        put("typeParameterDecl", MetaNode.TYPE_PARAMETER);
        put("typeElement", MetaNode.TYPE);
        put("typeTerm", MetaNode.TYPE);
        put("functionDecl", MetaNode.METHOD_DECLARATION);
        put("methodDecl", MetaNode.METHOD_DECLARATION);
        put("receiver", MetaNode.FORMAL_PARAMETERS);
        put("varDecl", MetaNode.LOCAL_VARIABLE_DECLARATION);
        put("varSpec", MetaNode.VARIABLE_DECLARATOR);
        put("block", MetaNode.BLOCK);
        put("statementList", MetaNode.BLOCK);
        put("statement", MetaNode.STATEMENT);
        put("simpleStmt", MetaNode.STATEMENT);
        put("expressionStmt", MetaNode.STATEMENT);
        put("sendStmt", MetaNode.STATEMENT);
        put("incDecStmt", MetaNode.STATEMENT);
        put("assignment", MetaNode.STATEMENT);
        put("assign_op", MetaNode.OP_ASSIGN);
        put("shortVarDecl", MetaNode.VARIABLE_DECLARATORS);
        put("labeledStmt", MetaNode.STATEMENT);
        put("returnStmt", MetaNode.STATEMENT);
        put("breakStmt", MetaNode.STATEMENT);
        put("continueStmt", MetaNode.STATEMENT);
        put("gotoStmt", MetaNode.STATEMENT);
        put("fallthroughStmt", MetaNode.STATEMENT);
        put("deferStmt", MetaNode.STATEMENT);
        put("ifStmt", MetaNode.STATEMENT);
        put("switchStmt", MetaNode.STATEMENT);
        put("exprSwitchStmt", MetaNode.STATEMENT);
        put("exprCaseClause", MetaNode.SWITCH_BLOCK_STATEMENT_GROUP);
        put("exprSwitchCase", MetaNode.SWITCH_LABELED_RULE);
        put("typeSwitchStmt", MetaNode.STATEMENT);
        put("typeSwitchGuard", MetaNode.SWITCH_LABELED_RULE);
        put("typeCaseClause", MetaNode.SWITCH_BLOCK_STATEMENT_GROUP);
        put("typeSwitchCase", MetaNode.SWITCH_LABELED_RULE);
        put("typeList", MetaNode.TYPE_LIST);
        put("selectStmt", MetaNode.STATEMENT);
        put("commClause", MetaNode.SWITCH_BLOCK_STATEMENT_GROUP);
        put("commCase", MetaNode.SWITCH_LABELED_RULE);
        put("recvStmt", MetaNode.STATEMENT);
        put("forStmt", MetaNode.STATEMENT);
        put("forClause", MetaNode.FOR_CONTROL);
        put("rangeClause", MetaNode.FOR_CONTROL);
        put("goStmt", MetaNode.STATEMENT);
        put("type_", MetaNode.TYPE);
        put("typeArgs", MetaNode.TYPE_ARGUMENTS);
        put("typeName", MetaNode.TYPE);
        put("typeLit", MetaNode.TYPE);
        put("arrayType", MetaNode.TYPE);
        put("arrayLength", MetaNode.EXPRESSION);
        put("elementType", MetaNode.TYPE);
        put("pointerType", MetaNode.TYPE);
        put("interfaceType", MetaNode.TYPE_INTERFACE);
        put("sliceType", MetaNode.TYPE);
        put("mapType", MetaNode.TYPE);
        put("channelType", MetaNode.TYPE);
        put("methodSpec", MetaNode.METHOD_DECLARATION);
        put("functionType", MetaNode.TYPE);
        put("signature", MetaNode.FORMAL_PARAMETERS);
        put("result", MetaNode.EXPRESSION);
        put("parameters", MetaNode.FORMAL_PARAMETERS);
        put("parameterDecl", MetaNode.FORMAL_PARAMETER);
        put("expression", MetaNode.EXPRESSION);
        put("primaryExpr", MetaNode.EXPRESSION);
        put("conversion", MetaNode.EXPRESSION);
        put("operand", MetaNode.EXPRESSION);
        put("literal", MetaNode.EXPRESSION);
        put("basicLit", MetaNode.NULL_LITERAL);
        put("integer", MetaNode.DECIMAL_LITERAL);
        put("operandName", MetaNode.IDENTIFIER);
        put("qualifiedIdent", MetaNode.IDENTIFIER);
        put("compositeLit", MetaNode.EXPRESSION);
        put("literalType", MetaNode.TYPE);
        put("literalValue", MetaNode.ARRAY_INITIALIZER);
        put("elementList", MetaNode.EXPRESSION_LIST);
        put("keyedElement", MetaNode.EXPRESSION);
        put("key", MetaNode.EXPRESSION);
        put("element", MetaNode.EXPRESSION);
        put("structType", MetaNode.TYPE);
        put("fieldDecl", MetaNode.FIELD_DECLARATION);
        put("string_", MetaNode.STRING_LITERAL);
        put("embeddedField", MetaNode.METHOD_CALL);
        put("functionLit", MetaNode.METHOD_CALL);
        put("index", MetaNode.EXPRESSION);
        put("slice_", MetaNode.EXPRESSION);
        put("typeAssertion", MetaNode.TYPE_OF);
        put("arguments", MetaNode.ARGUMENTS);
        put("methodExpr", MetaNode.METHOD_CALL);
        put("eos", VOID_MAPPING);

        put("null", MetaNode.NULL_LITERAL);
        put("BREAK", MetaNode.STATEMENT_BREAK);
        put("DEFAULT", MetaNode.STATEMENT_DEFAULT);
        put("FUNC", MetaNode.METHOD_DECLARATION);
        put("INTERFACE", MetaNode.INTERFACE_DECLARATION);
        put("SELECT", MetaNode.STATEMENT_SWITCH);
        put("CASE", MetaNode.STATEMENT_CASE);
        put("DEFER", VOID_MAPPING);
        put("GO", VOID_MAPPING);
        put("MAP", MetaNode.TYPE_LIST);
        put("STRUCT", MetaNode.TYPE_STRUCT);
        put("CHAN", VOID_MAPPING);
        put("ELSE", MetaNode.STATEMENT_ELSE);
        put("GOTO", MetaNode.STATEMENT_GOTO);
        put("PACKAGE", VOID_MAPPING);
        put("SWITCH", MetaNode.STATEMENT_SWITCH);
        put("CONST", MetaNode.MODIFIER_CONST);
        put("FALLTHROUGH", VOID_MAPPING);
        put("IF", MetaNode.STATEMENT_IF);
        put("RANGE", VOID_MAPPING);
        put("TYPE", MetaNode.TYPEDEF);
        put("CONTINUE", MetaNode.STATEMENT_CONTINUE);
        put("FOR", MetaNode.STATEMENT_FOR);
        put("IMPORT", VOID_MAPPING);
        put("RETURN", MetaNode.STATEMENT_RETURN);
        put("VAR", MetaNode.TYPE_VAR);
        put("NIL_LIT", MetaNode.NULL_LITERAL);
        put("IDENTIFIER", MetaNode.IDENTIFIER);
        put("L_PAREN", VOID_MAPPING);
        put("R_PAREN", VOID_MAPPING);
        put("L_CURLY", VOID_MAPPING);
        put("R_CURLY", VOID_MAPPING);
        put("L_BRACKET", MetaNode.L_SQUARE);
        put("R_BRACKET", MetaNode.R_SQUARE);
        put("ASSIGN", MetaNode.OP_ASSIGN);
        put("COMMA", VOID_MAPPING);
        put("SEMI", VOID_MAPPING);
        put("COLON", VOID_MAPPING);
        put("DOT", MetaNode.DOT);
        put("PLUS_PLUS", MetaNode.OP_INC);
        put("MINUS_MINUS", MetaNode.OP_DEC);
        put("DECLARE_ASSIGN", MetaNode.OP_ASSIGN);
        put("ELLIPSIS", MetaNode.MODIFIER_VARARGS);
        put("LOGICAL_OR", MetaNode.OP_OR);
        put("LOGICAL_AND", MetaNode.OP_AND);
        put("EQUALS", MetaNode.OP_EQUAL);
        put("NOT_EQUALS", MetaNode.OP_NOTEQUAL);
        put("LESS", MetaNode.OP_LT);
        put("LESS_OR_EQUALS", MetaNode.OP_LE);
        put("GREATER", MetaNode.OP_GT);
        put("GREATER_OR_EQUALS", MetaNode.OP_GE);
        put("OR", MetaNode.OP_BITOR);
        put("DIV", MetaNode.OP_DIV);
        put("MOD", MetaNode.OP_MOD);
        put("LSHIFT", MetaNode.OP_LSHIFT);
        put("RSHIFT", MetaNode.OP_RSHIFT);
        put("BIT_CLEAR", MetaNode.OP_BITAND);
        put("UNDERLYING", VOID_MAPPING);
        put("EXCLAMATION", MetaNode.OP_NOT);
        put("PLUS", MetaNode.OP_ADD);
        put("MINUS", MetaNode.OP_SUB);
        put("CARET", MetaNode.OP_XOR);
        put("STAR", MetaNode.OP_MUL);
        put("AMPERSAND", MetaNode.OP_BITAND);
        put("RECEIVE", VOID_MAPPING);
        put("DECIMAL_LIT", MetaNode.DECIMAL_LITERAL);
        put("BINARY_LIT", MetaNode.BINARY_LITERAL);
        put("OCTAL_LIT", MetaNode.OCT_LITERAL);
        put("HEX_LIT", MetaNode.HEX_LITERAL);
        put("FLOAT_LIT", MetaNode.FLOAT_LITERAL);
        put("DECIMAL_FLOAT_LIT", MetaNode.DECIMAL_LITERAL);
        put("HEX_FLOAT_LIT", MetaNode.HEX_FLOAT_LITERAL);
        put("IMAGINARY_LIT", MetaNode.DECIMAL_LITERAL);
        put("RUNE_LIT", MetaNode.CHAR_LITERAL);
        put("BYTE_VALUE", MetaNode.TYPE_BYTE);
        put("OCTAL_BYTE_VALUE", MetaNode.OCT_LITERAL);
        put("HEX_BYTE_VALUE", MetaNode.HEX_LITERAL);
        put("LITTLE_U_VALUE", MetaNode.TYPE_UNSIGNED);
        put("BIG_U_VALUE", MetaNode.TYPE_UNSIGNED);
        put("RAW_STRING_LIT", MetaNode.STRING_LITERAL);
        put("INTERPRETED_STRING_LIT", MetaNode.STRING_LITERAL);
        put("WS", VOID_MAPPING);
        put("COMMENT", VOID_MAPPING);
        put("TERMINATOR", VOID_MAPPING);
        put("LINE_COMMENT", VOID_MAPPING);
        put("WS_NLSEMI", VOID_MAPPING);
        put("COMMENT_NLSEMI", VOID_MAPPING);
        put("LINE_COMMENT_NLSEMI", VOID_MAPPING);
        put("EOS", VOID_MAPPING);
        put("OTHER", VOID_MAPPING);
        put("EOF", VOID_MAPPING);
    }});

    private GoLanguageMapper(final Map<String, MetaNode> mappings) {
        super(mappings);
    }
}
