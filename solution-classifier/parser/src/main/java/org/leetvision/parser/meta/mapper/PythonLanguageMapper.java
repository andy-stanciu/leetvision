package org.leetvision.parser.meta.mapper;

import org.leetvision.parser.meta.MetaLanguage;

import java.util.HashMap;
import java.util.Map;

import static org.leetvision.parser.meta.MetaLanguage.MetaNode;

public final class PythonLanguageMapper extends LanguageMapper {
    public static final PythonLanguageMapper INSTANCE = new PythonLanguageMapper(new HashMap<>() {{
        put("single_input", VOID_MAPPING);
        put("file_input", MetaNode.PROGRAM);
        put("eval_input", VOID_MAPPING);
        put("decorator", VOID_MAPPING);
        put("decorators", VOID_MAPPING);
        put("decorated", MetaNode.CLASS_DECLARATION);  // hack
        put("async_funcdef", MetaNode.METHOD_DECLARATION);
        put("funcdef", MetaNode.METHOD_DECLARATION);
        put("parameters", MetaNode.FORMAL_PARAMETERS);
        put("typedargslist", MetaNode.FORMAL_PARAMETERS);
        put("tfpdef", MetaNode.FORMAL_PARAMETER);
        put("varargslist", MetaNode.LAMBDA_PARAMETERS);
        put("vfpdef", MetaNode.FORMAL_PARAMETER);
        put("stmt", MetaNode.STATEMENT);
        put("simple_stmts", MetaNode.BLOCK);
        put("simple_stmt", MetaNode.STATEMENT);
        put("expr_stmt", MetaNode.STATEMENT);
        put("annassign", MetaNode.INITIALIZER);
        put("testlist_star_expr", MetaNode.EXPRESSION_LIST);
        put("augassign", MetaNode.OP_ASSIGN);  // hack
        put("del_stmt", MetaNode.STATEMENT);
        put("pass_stmt", VOID_MAPPING);
        put("flow_stmt", MetaNode.STATEMENT);
        put("break_stmt", MetaNode.STATEMENT);
        put("continue_stmt", MetaNode.STATEMENT);
        put("return_stmt", MetaNode.STATEMENT);
        put("yield_stmt", MetaNode.STATEMENT);
        put("raise_stmt", MetaNode.STATEMENT);
        put("import_stmt", VOID_MAPPING);
        put("import_name", VOID_MAPPING);
        put("import_from", VOID_MAPPING);
        put("import_as_name", VOID_MAPPING);
        put("dotted_as_name", VOID_MAPPING);
        put("dotted_name", VOID_MAPPING);
        put("global_stmt", MetaNode.STATEMENT);
        put("nonlocal_stmt", MetaNode.STATEMENT);
        put("assert_stmt", MetaNode.STATEMENT);
        put("compound_stmt", MetaNode.STATEMENT);
        put("async_stmt", MetaNode.STATEMENT);
        put("if_stmt", MetaNode.STATEMENT);
        put("while_stmt", MetaNode.STATEMENT);
        put("for_stmt", MetaNode.STATEMENT);
        put("try_stmt", MetaNode.STATEMENT);
        put("with_stmt", MetaNode.STATEMENT);
        put("with_item", MetaNode.EXPRESSION);
        put("except_clause", MetaNode.CATCH_CLAUSE);
        put("block", MetaNode.BLOCK);
        put("match_stmt", MetaNode.STATEMENT);
        put("subject_expr", MetaNode.EXPRESSION);
        put("star_named_expressions", MetaNode.EXPRESSION_LIST);
        put("star_named_expression", MetaNode.EXPRESSION);
        put("case_block", MetaNode.STATEMENT_CASE);
        put("guard", MetaNode.OP_TERNARY);
        put("patterns", MetaNode.EXPRESSION_LIST);
        put("pattern", MetaNode.PATTERN);
        put("as_pattern", MetaNode.PATTERN);
        put("or_pattern", MetaNode.PATTERN);
        put("closed_pattern", MetaNode.PATTERN);
        put("literal_pattern", MetaNode.PATTERN);
        put("literal_expr", MetaNode.EXPRESSION);
        put("complex_number", MetaNode.DECIMAL_LITERAL);
        put("signed_number", MetaNode.DECIMAL_LITERAL);
        put("signed_real_number", MetaNode.DECIMAL_LITERAL);
        put("real_number", MetaNode.DECIMAL_LITERAL);
        put("imaginary_number", MetaNode.DECIMAL_LITERAL);
        put("capture_pattern", MetaNode.PATTERN);
        put("pattern_capture_target", MetaNode.PATTERN);
        put("wildcard_pattern", MetaNode.PATTERN);
        put("value_pattern", MetaNode.PATTERN);
        put("attr", MetaNode.IDENTIFIER);
        put("name_or_attr", MetaNode.IDENTIFIER);
        put("group_pattern", MetaNode.PATTERN);
        put("sequence_pattern", MetaNode.PATTERN);
        put("open_sequence_pattern", MetaNode.PATTERN);
        put("maybe_sequence_pattern", MetaNode.PATTERN);
        put("maybe_star_pattern", MetaNode.PATTERN);
        put("star_pattern", MetaNode.PATTERN);
        put("mapping_pattern", MetaNode.PATTERN);
        put("items_pattern", MetaNode.PATTERN);
        put("key_value_pattern", MetaNode.PATTERN);
        put("double_star_pattern", MetaNode.PATTERN);
        put("class_pattern", MetaNode.PATTERN);
        put("positional_patterns", MetaNode.EXPRESSION_LIST);
        put("keyword_patterns", MetaNode.EXPRESSION_LIST);
        put("keyword_pattern", MetaNode.PATTERN);
        put("test", MetaNode.EXPRESSION);
        put("test_nocond", MetaNode.EXPRESSION);
        put("lambdef", MetaNode.LAMBDA_EXPRESSION);
        put("lambdef_nocond", MetaNode.LAMBDA_EXPRESSION);
        put("or_test", MetaNode.EXPRESSION);
        put("and_test", MetaNode.EXPRESSION);
        put("not_test", MetaNode.EXPRESSION);
        put("comparison", MetaNode.EXPRESSION);
        put("comp_op", MetaNode.OP_LT);  // hack
        put("star_expr", VOID_MAPPING);  // python unpacking is weird
        put("expr", MetaNode.EXPRESSION);
        put("atom_expr", MetaNode.EXPRESSION);
        put("atom", MetaNode.DECIMAL_LITERAL);  // hack
        put("name", MetaNode.IDENTIFIER);
        put("testlist_comp", MetaNode.EXPRESSION_LIST);
        put("trailer", MetaNode.EXPRESSION_LIST);
        put("subscriptlist", MetaNode.EXPRESSION_LIST);
        put("subscript_", MetaNode.EXPRESSION);
        put("sliceop", MetaNode.OP_SLICE);
        put("exprlist", MetaNode.EXPRESSION_LIST);
        put("testlist", MetaNode.EXPRESSION_LIST);
        put("dictorsetmaker", MetaNode.CREATOR);
        put("classdef", MetaNode.CLASS_DECLARATION);
        put("arglist", MetaNode.ARGUMENTS);
        put("argument", MetaNode.EXPRESSION);
        put("comp_iter", MetaNode.STATEMENT_FOR); // hack
        put("comp_for", MetaNode.STATEMENT_FOR);
        put("comp_if", MetaNode.OP_TERNARY);
        put("encoding_decl", MetaNode.IDENTIFIER);
        put("yield_expr", MetaNode.STATEMENT_YIELD);
        put("yield_arg", MetaNode.EXPRESSION);
        put("strings", MetaNode.STRING_LITERAL);
        put("null", MetaNode.NULL_LITERAL);
        put("INDENT", VOID_MAPPING);
        put("DEDENT", VOID_MAPPING);
        put("STRING", MetaNode.STRING_LITERAL);
        put("NUMBER", MetaNode.DECIMAL_LITERAL);
        put("INTEGER", MetaNode.DECIMAL_LITERAL);
        put("AND", MetaNode.OP_AND);
        put("AS", MetaNode.CAST);
        put("ASSERT", MetaNode.STATEMENT_ASSERT);
        put("ASYNC", VOID_MAPPING);
        put("AWAIT", VOID_MAPPING);
        put("BREAK", MetaNode.STATEMENT_BREAK);
        put("CASE", MetaNode.STATEMENT_CASE);
        put("CLASS", MetaNode.TYPE_CLASS);
        put("CONTINUE", MetaNode.STATEMENT_CONTINUE);
        put("DEF", VOID_MAPPING);  // redundant
        put("DEL", MetaNode.FREE);
        put("ELIF", MetaNode.STATEMENT_ELSE);
        put("ELSE", MetaNode.STATEMENT_ELSE);
        put("EXCEPT", MetaNode.STATEMENT_CATCH);
        put("FALSE", MetaNode.BOOL_LITERAL);
        put("FINALLY", MetaNode.STATEMENT_FINALLY);
        put("FOR", MetaNode.STATEMENT_FOR);
        put("FROM", VOID_MAPPING);
        put("GLOBAL", VOID_MAPPING);
        put("IF", MetaNode.STATEMENT_IF);
        put("IMPORT", VOID_MAPPING);
        put("IN", MetaNode.OP_IN);
        put("IS", MetaNode.TYPE_OF);
        put("LAMBDA", MetaNode.OP_LAMBDA);
        put("MATCH", MetaNode.STATEMENT_MATCH);
        put("NONE", MetaNode.NULL_LITERAL);
        put("NONLOCAL", VOID_MAPPING);
        put("NOT", MetaNode.OP_NOT);
        put("OR", MetaNode.OP_OR);
        put("PASS", VOID_MAPPING);
        put("RAISE", MetaNode.STATEMENT_THROW);
        put("RETURN", MetaNode.STATEMENT_RETURN);
        put("TRUE", MetaNode.BOOL_LITERAL);
        put("TRY", MetaNode.STATEMENT_TRY);
        put("UNDERSCORE", VOID_MAPPING);
        put("WHILE", MetaNode.STATEMENT_WHILE);
        put("WITH", VOID_MAPPING);
        put("YIELD", MetaNode.STATEMENT_YIELD);
        put("NEWLINE", VOID_MAPPING);
        put("NAME", MetaNode.IDENTIFIER);
        put("STRING_LITERAL", MetaNode.STRING_LITERAL);
        put("BYTES_LITERAL", MetaNode.STRING_LITERAL);
        put("DECIMAL_INTEGER", MetaNode.DECIMAL_LITERAL);
        put("OCT_INTEGER", MetaNode.OCT_LITERAL);
        put("HEX_INTEGER", MetaNode.HEX_LITERAL);
        put("BIN_INTEGER", MetaNode.BINARY_LITERAL);
        put("FLOAT_NUMBER", MetaNode.FLOAT_LITERAL);
        put("IMAG_NUMBER", MetaNode.DECIMAL_LITERAL);
        put("DOT", MetaNode.DOT);
        put("ELLIPSIS", MetaNode.MODIFIER_VARARGS);
        put("STAR", MetaNode.OP_MUL);
        put("OPEN_PAREN", VOID_MAPPING);
        put("CLOSE_PAREN", VOID_MAPPING);
        put("COMMA", VOID_MAPPING);
        put("COLON", VOID_MAPPING);
        put("SEMI_COLON", VOID_MAPPING);
        put("POWER", MetaNode.OP_POWER);
        put("ASSIGN", MetaNode.OP_ASSIGN);
        put("OPEN_BRACK", MetaNode.L_SQUARE);
        put("CLOSE_BRACK", MetaNode.R_SQUARE);
        put("OR_OP", MetaNode.OP_BITOR);
        put("XOR", MetaNode.OP_XOR);
        put("AND_OP", MetaNode.OP_BITAND);
        put("LEFT_SHIFT", MetaNode.OP_LSHIFT);
        put("RIGHT_SHIFT", MetaNode.OP_RSHIFT);
        put("ADD", MetaNode.OP_ADD);
        put("MINUS", MetaNode.OP_SUB);
        put("DIV", MetaNode.OP_DIV);
        put("MOD", MetaNode.OP_MOD);
        put("IDIV", MetaNode.OP_DIV);
        put("NOT_OP", MetaNode.OP_BITNOT);
        put("OPEN_BRACE", VOID_MAPPING);
        put("CLOSE_BRACE", VOID_MAPPING);
        put("LESS_THAN", MetaNode.OP_LT);
        put("GREATER_THAN", MetaNode.OP_GT);
        put("EQUALS", MetaNode.OP_EQUAL);
        put("GT_EQ", MetaNode.OP_GE);
        put("LT_EQ", MetaNode.OP_LE);
        put("NOT_EQ_1", MetaNode.OP_NOTEQUAL);
        put("NOT_EQ_2", MetaNode.OP_NOTEQUAL);
        put("AT", VOID_MAPPING);
        put("ARROW", VOID_MAPPING);
        put("ADD_ASSIGN", MetaNode.OP_ADD_ASSIGN);
        put("SUB_ASSIGN", MetaNode.OP_SUB_ASSIGN);
        put("MULT_ASSIGN", MetaNode.OP_MUL_ASSIGN);
        put("AT_ASSIGN", VOID_MAPPING);
        put("DIV_ASSIGN", MetaNode.OP_DIV_ASSIGN);
        put("MOD_ASSIGN", MetaNode.OP_MOD_ASSIGN);
        put("AND_ASSIGN", MetaNode.OP_AND_ASSIGN);
        put("OR_ASSIGN", MetaNode.OP_OR_ASSIGN);
        put("XOR_ASSIGN", MetaNode.OP_XOR_ASSIGN);
        put("LEFT_SHIFT_ASSIGN", MetaNode.OP_LSHIFT_ASSIGN);
        put("RIGHT_SHIFT_ASSIGN", MetaNode.OP_RSHIFT_ASSIGN);
        put("POWER_ASSIGN", MetaNode.OP_MUL_ASSIGN);  // no way
        put("IDIV_ASSIGN", MetaNode.OP_DIV_ASSIGN);
        put("SKIP_", VOID_MAPPING);
        put("UNKNOWN_CHAR", VOID_MAPPING);
        put("EOF", VOID_MAPPING);
    }});


    private PythonLanguageMapper(final Map<String, MetaLanguage.MetaNode> mappings) {
        super(mappings);
    }
}
